Monte Carlo Simulations in Exotic Options Pricing and Risk Metrics
Use Case 1: Exotic Options Pricing
Exotic Options like barrier options, Asian options, and quanto options have payoff structures that are path-dependent or influenced by multiple factors. For these, Monte Carlo simulations are indispensable because:

They allow flexibility in handling complex payoffs.
Closed-form solutions often donâ€™t exist for these options.
Example Scenario: Pricing a Multi-Asset Basket Option
Description: A basket optionâ€™s payoff depends on the performance of a weighted portfolio of underlying assets (e.g., a stock index or a basket of commodities).
Challenge: The payoff is path-dependent, and the correlation between assets must be accurately modeled.
Steps:
Model Asset Price Dynamics: Each asset in the basket follows a Geometric Brownian Motion (GBM):

ğ‘‘
ğ‘†
ğ‘–
=
ğœ‡
ğ‘–
ğ‘†
ğ‘–
ğ‘‘
ğ‘¡
+
ğœ
ğ‘–
ğ‘†
ğ‘–
ğ‘‘
ğ‘Š
ğ‘–
dS 
i
â€‹
 =Î¼ 
i
â€‹
 S 
i
â€‹
 dt+Ïƒ 
i
â€‹
 S 
i
â€‹
 dW 
i
â€‹
 
where 
ğ‘†
ğ‘–
S 
i
â€‹
  is the price of asset 
ğ‘–
i, 
ğœ‡
ğ‘–
Î¼ 
i
â€‹
  is the drift, 
ğœ
ğ‘–
Ïƒ 
i
â€‹
  is volatility, and 
ğ‘‘
ğ‘Š
ğ‘–
dW 
i
â€‹
  is the Wiener process.

Simulate Correlated Price Paths:

Correlations: Use a covariance matrix for asset returns.
Cholesky Decomposition: Decompose the covariance matrix to generate correlated random variables:
ğ‘
=
ğ¿
â‹…
ğœ–
Z=Lâ‹…Ïµ
where 
ğ¿
L is the Cholesky matrix, and 
ğœ–
Ïµ is a vector of independent standard normal variables.
Calculate Payoffs:

For a basket call option:
Payoff
=
max
â¡
(
âˆ‘
ğ‘¤
ğ‘–
ğ‘†
ğ‘–
(
ğ‘‡
)
âˆ’
ğ¾
,
0
)
Payoff=max(âˆ‘w 
i
â€‹
 S 
i
â€‹
 (T)âˆ’K,0)
where 
ğ‘¤
ğ‘–
w 
i
â€‹
  are the asset weights, 
ğ‘†
ğ‘–
(
ğ‘‡
)
S 
i
â€‹
 (T) are the simulated terminal prices, and 
ğ¾
K is the strike price.
Discount Expected Payoff: Compute the option price by averaging the discounted payoffs across all simulations:

Price
=
ğ‘’
âˆ’
ğ‘Ÿ
ğ‘‡
â‹…
1
ğ‘
âˆ‘
ğ‘—
=
1
ğ‘
Payoff
ğ‘—
Price=e 
âˆ’rT
 â‹… 
N
1
â€‹
  
j=1
âˆ‘
N
â€‹
 Payoff 
j
â€‹
 
Benefits:
Handles non-linearities and path dependencies.
Incorporates realistic correlations between assets.
Use Case 2: Risk Metrics (VaR and CVaR)
VaR (Value at Risk): Measures the potential loss in a portfolio over a specified time frame at a given confidence level.
CVaR (Conditional Value at Risk): Estimates the average loss beyond the VaR threshold.
Example Scenario: Portfolio VaR Estimation
Simulate Portfolio Returns:

Each assetâ€™s return is modeled as:
ğ‘…
ğ‘–
=
ğœ‡
ğ‘–
Î”
ğ‘¡
+
ğœ
ğ‘–
Î”
ğ‘¡
ğ‘
ğ‘–
R 
i
â€‹
 =Î¼ 
i
â€‹
 Î”t+Ïƒ 
i
â€‹
  
Î”t
â€‹
 Z 
i
â€‹
 
where 
ğ‘
ğ‘–
Z 
i
â€‹
  are correlated random variables generated using Cholesky decomposition.
Aggregate Portfolio Returns: Combine simulated returns to compute the portfolioâ€™s return for each iteration:

ğ‘…
portfolio
=
âˆ‘
ğ‘¤
ğ‘–
ğ‘…
ğ‘–
R 
portfolio
â€‹
 =âˆ‘w 
i
â€‹
 R 
i
â€‹
 
where 
ğ‘¤
ğ‘–
w 
i
â€‹
  are asset weights.

Construct the Distribution:

Simulate thousands of portfolio returns to build a return distribution.
Sort the simulated returns in ascending order.
Compute Risk Metrics:

VaR: Identify the return at the desired percentile (e.g., 5% for a 95% confidence level).
CVaR: Calculate the average of returns below the VaR threshold.
Benefits:
Incorporates non-linear effects and fat tails in return distributions.
Adaptable to portfolios with derivatives or complex positions.
Integration with Cholesky Decomposition
Why Cholesky?

Ensures that simulated asset returns adhere to the real-world correlation structure.
Efficient for large covariance matrices.
Cholesky Workflow:
Calculate the covariance matrix, 
Î£
Î£, of asset returns.
Decompose 
Î£
Î£ into 
ğ¿
L such that:
Î£
=
ğ¿
â‹…
ğ¿
ğ‘‡
Î£=Lâ‹…L 
T
 
Generate correlated random variables:
ğ‘…
correlated
=
ğ¿
â‹…
ğ‘
R 
correlated
â€‹
 =Lâ‹…Z
where 
ğ‘
Z is a vector of uncorrelated standard normals.


import numpy as np
import scipy.linalg

def simulate_basket_option_price(
    S0, weights, mu, sigma, corr_matrix, T, r, K, num_simulations, num_steps
):
    """
    Simulate the price of a multi-asset basket option using Monte Carlo.

    Parameters:
        S0 (np.array): Initial prices of the assets.
        weights (np.array): Weights of each asset in the basket.
        mu (np.array): Drift rates of the assets.
        sigma (np.array): Volatilities of the assets.
        corr_matrix (np.array): Correlation matrix of the assets.
        T (float): Time to maturity (in years).
        r (float): Risk-free rate.
        K (float): Strike price.
        num_simulations (int): Number of Monte Carlo simulations.
        num_steps (int): Number of time steps.

    Returns:
        float: Simulated price of the basket option.
    """
    num_assets = len(S0)
    dt = T / num_steps

    # Cholesky decomposition of the correlation matrix
    L = scipy.linalg.cholesky(corr_matrix, lower=True)

    # Simulate correlated asset paths
    prices = np.zeros((num_simulations, num_assets))
    for sim in range(num_simulations):
        S = S0.copy()
        for _ in range(num_steps):
            Z = np.random.normal(size=num_assets)  # Generate uncorrelated random variables
            correlated_Z = L @ Z  # Apply Cholesky to introduce correlation
            S = S * np.exp((mu - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * correlated_Z)
        prices[sim] = S

    # Calculate basket payoffs
    basket_values = np.sum(weights * prices, axis=1)
    payoffs = np.maximum(basket_values - K, 0)

    # Discount payoffs to present value
    option_price = np.exp(-r * T) * np.mean(payoffs)
    return option_price

# Example parameters
S0 = np.array([100, 95, 90])  # Initial prices of 3 assets
weights = np.array([0.4, 0.35, 0.25])  # Weights in the basket
mu = np.array([0.05, 0.03, 0.04])  # Drift rates
sigma = np.array([0.2, 0.25, 0.3])  # Volatilities
corr_matrix = np.array([
    [1.0, 0.8, 0.5],
    [0.8, 1.0, 0.6],
    [0.5, 0.6, 1.0],
])  # Correlation matrix
T = 1.0  # Time to maturity (1 year)
r = 0.05  # Risk-free rate
K = 95  # Strike price
num_simulations = 10000  # Number of simulations
num_steps = 252  # Number of time steps (daily)

# Compute option price
basket_option_price = simulate_basket_option_price(S0, weights, mu, sigma, corr_matrix, T, r, K, num_simulations, num_steps)
print(f"Simulated Basket Option Price: {basket_option_price:.2f}")


Here's a line-by-line explanation of the provided Python code for simulating the price of a multi-asset basket option using Monte Carlo simulations.

Function Definition
python
Copy code
def simulate_basket_option_price(S0, weights, mu, sigma, corr_matrix, T, r, K, num_simulations, num_steps):
    """
    Simulate the price of a multi-asset basket option using Monte Carlo.
    """
S0: Initial prices of the assets (array).
weights: Weight of each asset in the basket (array).
mu: Drift rates of the assets (array).
sigma: Volatilities of the assets (array).
corr_matrix: Correlation matrix representing dependencies between assets.
T: Time to maturity of the option in years (float).
r: Risk-free interest rate (float).
K: Strike price of the basket option (float).
num_simulations: Number of Monte Carlo simulations to perform (int).
num_steps: Number of time steps in each simulation (int).
The function will return the simulated price of the basket option.

Preliminary Setup
python
Copy code
    num_assets = len(S0)
    dt = T / num_steps
num_assets: Number of assets in the basket (length of S0).
dt: Time increment per step (\Delta t = T / \text{num_steps}).
Cholesky Decomposition
python
Copy code
    L = scipy.linalg.cholesky(corr_matrix, lower=True)
Cholesky Decomposition: Decomposes the correlation matrix into a lower triangular matrix 
ğ¿
L, which is used to generate correlated random variables.
Simulate Correlated Asset Paths
python
Copy code
    prices = np.zeros((num_simulations, num_assets))
    for sim in range(num_simulations):
        S = S0.copy()
        for _ in range(num_steps):
            Z = np.random.normal(size=num_assets)  # Generate uncorrelated random variables
            correlated_Z = L @ Z  # Apply Cholesky to introduce correlation
            S = S * np.exp((mu - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * correlated_Z)
        prices[sim] = S
prices: An array to store the simulated terminal prices of all assets for all simulations.

Outer loop (sim): Iterates over the number of simulations.

S: Stores the asset prices for the current simulation. Initialized to S0 (initial prices).

Inner loop (steps): Simulates the price evolution of assets step-by-step:

Z: Generates independent standard normal random variables for each asset.
correlated_Z: Multiplies 
ğ‘
Z by 
ğ¿
L to introduce the correlation structure between assets.
Price Update Formula:
ğ‘†
=
ğ‘†
â‹…
ğ‘’
(
ğœ‡
âˆ’
0.5
â‹…
ğœ
2
)
â‹…
ğ‘‘
ğ‘¡
+
ğœ
â‹…
ğ‘‘
ğ‘¡
â‹…
correlated_Z
S=Sâ‹…e 
(Î¼âˆ’0.5â‹…Ïƒ 
2
 )â‹…dt+Ïƒâ‹… 
dt
â€‹
 â‹…correlated_Z
 
This represents the Geometric Brownian Motion (GBM) model for each asset.
Store Terminal Prices: After all time steps, the final prices 
ğ‘†
S are stored in prices[sim].

Calculate Basket Payoffs
python
Copy code
    basket_values = np.sum(weights * prices, axis=1)
    payoffs = np.maximum(basket_values - K, 0)
basket_values: Computes the weighted sum of asset prices for each simulation, representing the value of the basket at maturity.
basket_value
=
âˆ‘
(
weights
ğ‘–
â‹…
price
ğ‘–
)
basket_value=âˆ‘(weights 
i
â€‹
 â‹…price 
i
â€‹
 )
payoffs: Calculates the payoff of the basket option for each simulation:
payoff
=
max
â¡
(
basket_value
âˆ’
ğ¾
,
0
)
payoff=max(basket_valueâˆ’K,0)
This represents the intrinsic value of the option.
Discount Payoffs to Present Value
python
Copy code
    option_price = np.exp(-r * T) * np.mean(payoffs)
    return option_price
Discount Factor: 
ğ‘’
âˆ’
ğ‘Ÿ
â‹…
ğ‘‡
e 
âˆ’râ‹…T
  discounts the future payoff to its present value.
Average Payoff: The mean of all discounted payoffs across simulations provides the Monte Carlo estimate of the option price.
Return the Result: The function returns the simulated option price.
Example Parameters
python
Copy code
S0 = np.array([100, 95, 90])  # Initial prices of 3 assets
weights = np.array([0.4, 0.35, 0.25])  # Weights in the basket
mu = np.array([0.05, 0.03, 0.04])  # Drift rates
sigma = np.array([0.2, 0.25, 0.3])  # Volatilities
corr_matrix = np.array([
    [1.0, 0.8, 0.5],
    [0.8, 1.0, 0.6],
    [0.5, 0.6, 1.0],
])  # Correlation matrix
T = 1.0  # Time to maturity (1 year)
r = 0.05  # Risk-free rate
K = 95  # Strike price
num_simulations = 10000  # Number of simulations
num_steps = 252  # Number of time steps (daily)
3 Assets with given initial prices, volatilities, and drift rates.
Correlation Matrix models dependencies between asset returns.
T = 1 year, simulated with 252 daily time steps.
10,000 simulations to ensure a robust estimate.
Run the Simulation
python
Copy code
basket_option_price = simulate_basket_option_price(
    S0, weights, mu, sigma, corr_matrix, T, r, K, num_simulations, num_steps
)
print(f"Simulated Basket Option Price: {basket_option_price:.2f}")
Calls the function with example parameters.
Prints the final simulated price of the basket option.
Output
For the given parameters, the output is the simulated basket option price. The value will vary slightly due to the randomness in Monte Carlo simulations.

Would you like to explore further enhancements, such as improving efficiency or parallelizing the simulation?












